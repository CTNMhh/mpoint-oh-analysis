// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========== USER MODELS ==========
model User {
  id           String    @id @default(uuid())
  username     String    @unique
  email        String    @unique
  password     String
  anrede       String
  titel        String?
  firstName    String
  lastName     String
  role         UserRole  @default(FREE)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  company      Company[]
  matchingPreferences MatchingPreferences?
  sentMatches     Match[] @relation("MatchSender")
  receivedMatches Match[] @relation("MatchReceiver")
  activities      Activity[]
  interactions    Interaction[]
  bookings       Booking[] // <-- Opposite relation for Booking
  events         Event[]   // <-- Opposite relation for Event
  eventActivityLogs   EventActivityLog[] @relation("UserEventLogs")
  carts    Cart[]    // Ein User kann mehrere Warenkörbe haben
  transactions Transaction[] // <--- Gegenrelation für Transaction
}



enum UserRole {
  FREE
  BASIC
  PREMIUM
  ENTERPRISE
}
// ========== COMPANY MODELS ==========
// ========== COMPANY MODELS ==========
model Company {
  id           String    @id @default(uuid())
  userId       String

  // Basis-Informationen
  name         String
  legalForm    String?
  foundedYear  Int
  registrationNumber String?

  digitalizationLevel Int    @default(1) // 1-10, Digitalisierungsgrad
  itBudgetPercent     Float?
  // Größenklasse
  employeeCount    Int       @default(1)
  employeeRange    EmployeeRange @default(SOLO)
  annualRevenue    Float     @default(0)
  revenueRange     RevenueRange @default(MICRO)

  // Lokation (Hamburg-spezifisch)
  street       String?
  zipCode      String?
  district     HamburgDistrict?
  primaryNaceCode   String? // <--- HINZUFÜGEN!

  // Geschäftsmodell
  customerType    CustomerType @default(B2B)
  customerCount   CustomerCountRange @default(VERY_SMALL)
  exportQuota     Int       @default(0)
  marketReach     MarketReach @default(LOCAL)
  seasonality     Seasonality @default(NONE)

  // Führung & Entscheidung
  leadershipStructure LeadershipStructure @default(OWNER_LED)
  decisionSpeed       DecisionSpeed @default(MODERATE)
  decisionMakers      Int @default(1)

  // Wachstum & Strategie
  growthPhase         GrowthPhase @default(ESTABLISHED)
  growthRate          Float @default(0)
  sustainabilityFocus Int @default(5)

  // Beschreibungen
  branchDescription   String?
  companyDescription  String?

  // Timestamps
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Matching Score (berechnet)
  matchingScore Float @default(0)
  profileCompleteness Float @default(0)
  lastMatchingUpdate DateTime @default(now())

  // Relations
  user      User     @relation(fields: [userId], references: [id])

  // Arrays als separate Models für bessere Queries
  locationAdvantages  LocationAdvantage[]
  industryTags       IndustryTag[]
  secondaryNaceCodes SecondaryNaceCode[]
  expansionPlans     ExpansionPlan[]
  certifications     Certification[]
  complianceNeeds    ComplianceNeed[]
  qualityStandards   QualityStandard[]
  painPoints         PainPoint[]
  searchingFor       SearchingFor[]
  offeringTo         OfferingTo[]

  // Matching Relations
  sentMatches        Match[] @relation("CompanySender")
  receivedMatches    Match[] @relation("CompanyReceiver")

  // Analytics
  activities         Activity[]
  interactions       Interaction[]

  @@index([district])
  @@index([employeeRange])
  @@index([revenueRange])
  @@index([customerType])
  @@index([marketReach])
  @@index([growthPhase])
  @@index([matchingScore])
  @@index([profileCompleteness])
}

// ========== COMPANY DETAIL MODELS ==========
model LocationAdvantage {
  id        String  @id @default(uuid())
  companyId String
  value     String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
}

model IndustryTag {
  id        String  @id @default(uuid())
  companyId String
  value     String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([value])
}

model SecondaryNaceCode {
  id        String  @id @default(uuid())
  companyId String
  code      String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([code])
}

model ExpansionPlan {
  id        String     @id @default(uuid())
  companyId String
  type      ExpansionType
  company   Company    @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([type])
}

model Certification {
  id        String  @id @default(uuid())
  companyId String
  name      String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([name])
}

model ComplianceNeed {
  id        String  @id @default(uuid())
  companyId String
  type      String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
}

model QualityStandard {
  id        String  @id @default(uuid())
  companyId String
  standard  String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
}

// ========== MATCHING MODELS ==========
model PainPoint {
  id        String  @id @default(uuid())
  companyId String
  point     String
  priority  Int     @default(5) // 1-10 Wichtigkeit
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([point])
}

model SearchingFor {
  id        String  @id @default(uuid())
  companyId String
  category  String
  details   String?
  priority  Int     @default(5)
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([category])
}

model OfferingTo {
  id        String  @id @default(uuid())
  companyId String
  category  String
  details   String?
  priority  Int     @default(5)
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([category])
}

// ========== MATCHING SYSTEM ==========
model MatchingPreferences {
  id     String @id @default(uuid())
  userId String @unique

  // Geografische Präferenzen
  maxDistance      Int @default(50) // km
  preferredDistricts HamburgDistrict[]

  // Unternehmensgröße Präferenzen
  minEmployees     Int?
  maxEmployees     Int?
  preferredSizes   EmployeeRange[]

  // Geschäftsmodell Präferenzen
  preferredCustomerTypes CustomerType[]
  preferredMarketReach   MarketReach[]

  // Wachstum & Innovation
  minGrowthRate    Float?
  preferredGrowthPhases GrowthPhase[]
  minSustainabilityFocus Int @default(1)

  // Matching Einstellungen
  autoMatch        Boolean @default(true)
  weeklyMatches    Int @default(5)
  matchingActive   Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Match {
  id            String      @id @default(uuid())

  // Match Partner
  senderUserId    String
  receiverUserId  String
  senderCompanyId String
  receiverCompanyId String

  // Match Details
  matchScore      Float       // 0-100
  matchType       MatchType
  status          MatchStatus @default(PENDING)

  // Matching Gründe (JSON)
  matchReasons    Json        // Warum diese Unternehmen matchen
  commonInterests Json        // Gemeinsame Interessen
  potentialSynergies Json     // Potentielle Synergien

  // Kommunikation
  message         String?
  response        String?

  // Zeitstempel
  matchedAt       DateTime    @default(now())
  respondedAt     DateTime?
  expiresAt       DateTime?   // Auto-expire nach X Tagen

  // Relations
  senderUser      User        @relation("MatchSender", fields: [senderUserId], references: [id])
  receiverUser    User        @relation("MatchReceiver", fields: [receiverUserId], references: [id])
  senderCompany   Company     @relation("CompanySender", fields: [senderCompanyId], references: [id])
  receiverCompany Company     @relation("CompanyReceiver", fields: [receiverCompanyId], references: [id])

  interactions    Interaction[]
  messages        Message[]   // <-- Opposite relation for Message

  @@unique([senderUserId, receiverUserId])
  @@index([status])
  @@index([matchScore])
  @@index([matchedAt])
  @@index([expiresAt])
}

model Message {
  id                 String   @id @default(uuid())
  matchId            String
  match              Match    @relation(fields: [matchId], references: [id])

  senderUserId       String
  senderCompanyId    String
  receiverUserId     String
  receiverCompanyId  String

  content            String
  createdAt          DateTime @default(now())
  readAt             DateTime?

  @@index([matchId, createdAt])
}

model Event {
  id              String   @id @default(uuid())
  title           String
  description     String
  imageUrl        String?
  startDate       DateTime
  endDate         DateTime?
  startTime       String?
  endTime         String?
  location        String
  ventType        String? // Veranstaltungstyp als Textfeld
  price           Float   @default(0)
  chargeFree      Boolean @default(false)  // NEU: Kostenfrei-Flag
  maxParticipants Int?
  bookedCount     Int     @default(0)
  organizer       String?
  calendarLinks   Json?
  categories      String[]
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // EVENT STATUS FELDER:
  status          EventStatus @default(DRAFT)
  isPublished     Boolean     @default(false)
  isActive        Boolean     @default(false)
  publishedAt     DateTime?
  cancelledAt     DateTime?
  cancelReason    String?

  // Relation zum User (Veranstalter)
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Relation zu Buchungen
  bookings        Booking[]

  // Relation zu Activity Logs
  activityLogs        EventActivityLog[] @relation("EventActivityLogs")

  // Gegenrelation für CartItem
  cartItems CartItem[]

  @@index([userId])
  @@index([chargeFree])  // NEU: Index für Performance
}

model Booking {
  id            String   @id @default(uuid())
  eventId       String
  userId        String?
  name          String
  email         String
  spaces        Int      @default(1)
  comment       String?
  bookingStatus BookingStatus @default(PENDING)
  pricePerSpace Float    @default(0)
  totalAmount   Float    @default(0)
  currency      String   @default("EUR")
  paymentStatus PaymentStatus @default(PENDING)
  paymentMethod String?
  transactionId String?
  refundedAmount  Float?
  refundedAt      DateTime?
  refundReason    String?
  updatedAt     DateTime @default(now())
  createdAt     DateTime @default(now())
  event         Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  User          User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  activityLogs  EventActivityLog[] @relation("BookingActivityLogs")
  transaction   Transaction? @relation(fields: [transactionId], references: [id])
  @@index([eventId])
  @@index([userId])
  @@index([paymentStatus])
  @@index([email])
}




// ========== INTERACTION TRACKING ==========
model Interaction {
  id        String          @id @default(uuid())
  userId    String
  companyId String
  matchId   String?

  type      InteractionType
  details   Json?           // Zusätzliche Details
  metadata  Json?           // Tracking Daten

  createdAt DateTime        @default(now())

  user      User            @relation(fields: [userId], references: [id])
  company   Company         @relation(fields: [companyId], references: [id])
  match     Match?          @relation(fields: [matchId], references: [id])

  @@index([userId])
  @@index([type])
  @@index([createdAt])
}

model Activity {
  id        String       @id @default(uuid())
  userId    String
  companyId String

  type      ActivityType
  title     String
  description String?
  data      Json?        // Flexible Datenstruktur

  createdAt DateTime     @default(now())

  user      User         @relation(fields: [userId], references: [id])
  company   Company      @relation(fields: [companyId], references: [id])

  @@index([userId])
  @@index([type])
  @@index([createdAt])
}

// ========== NEWS MODEL ==========
model News {
  id          String    @id @default(uuid())
  title       String
  subtitle    String?
  shortText   String    @db.Text
  longText    String    @db.Text
  imageUrl    String?
  author      String?
  category    NewsCategory @default(ALLGEMEIN)
  tags        String[]
  publishDate DateTime  @default(now())
  isPublished Boolean   @default(false)
  viewCount   Int      @default(0)
  readTime    String?  // Lesedauer z.B. "5 Min."
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([category])
  @@index([publishDate])
  @@index([isPublished])
}

// ========== ENUMS ==========
enum EmployeeRange {
  SOLO              // 1
  MICRO             // 2-9
  SMALL             // 10-49
  MEDIUM            // 50-249
  LARGE             // 250+
}
model Admin {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  firstName String
  lastName  String
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())
}

enum RevenueRange {
  MICRO             // < 100k
  SMALL             // 100k - 1M
  MEDIUM            // 1M - 10M
  LARGE             // 10M - 50M
  ENTERPRISE        // > 50M
}

enum HamburgDistrict {
  MITTE
  ALTONA
  EIMSBUETTEL
  NORD
  WANDSBEK
  BERGEDORF
  HARBURG
  HAFENCITY
  SPEICHERSTADT
  UMLAND_NORD
  UMLAND_SUED
}

enum CustomerType {
  B2B
  B2C
  B2B2C
  B2G
}

enum CustomerCountRange {
  VERY_SMALL        // < 10
  SMALL             // 10-100
  MEDIUM            // 100-1000
  LARGE             // 1000-10000
  ENTERPRISE        // > 10000
}

enum MarketReach {
  LOCAL             // Hamburg
  REGIONAL          // Norddeutschland
  NATIONAL          // Deutschland
  EU                // Europa
  GLOBAL            // Weltweit
}

enum Seasonality {
  NONE
  LOW
  MEDIUM
  HIGH
  EXTREME
}

enum LeadershipStructure {
  OWNER_LED
  FAMILY_BUSINESS
  PROFESSIONAL_MANAGEMENT
  PARTNERSHIP
  COOPERATIVE
}

enum DecisionSpeed {
  VERY_FAST         // 1-3 Tage
  FAST              // 4-7 Tage
  MODERATE          // 1-2 Wochen
  SLOW              // 3-4 Wochen
  VERY_SLOW         // > 4 Wochen
}

enum GrowthPhase {
  STARTUP           // < 2 Jahre
  GROWTH            // 2-5 Jahre
  SCALING           // 5-10 Jahre
  ESTABLISHED       // 10-20 Jahre
  MATURE            // > 20 Jahre
  TRANSFORMATION    // Umbruch
}

enum ExpansionType {
  NEW_LOCATIONS
  NEW_PRODUCTS
  NEW_MARKETS
  DIGITALIZATION
  ACQUISITIONS
  INTERNATIONAL
}

enum MatchType {
  SUPPLIER_CUSTOMER     // Lieferant-Kunde
  PARTNERSHIP          // Kooperation
  SERVICE_PROVIDER     // Dienstleister
  COLLABORATION        // Zusammenarbeit
  NETWORKING          // Networking
  KNOWLEDGE_EXCHANGE  // Wissensaustausch
}

enum MatchStatus {
  PENDING
  ACCEPTED_BY_SENDER
  ACCEPTED_BY_RECEIVER
  CONNECTED
  REJECTED
}

enum InteractionType {
  PROFILE_VIEW
  MATCH_SENT
  MATCH_RECEIVED
  MATCH_ACCEPTED
  MATCH_DECLINED
  MESSAGE_SENT
  MESSAGE_READ
  CONTACT_SHARED
  MEETING_SCHEDULED
  BUSINESS_CARD_EXCHANGED
}

enum ActivityType {
  PROFILE_UPDATED
  MATCH_CREATED
  MATCH_SUCCESSFUL
  NEW_CONNECTION
  PROFILE_COMPLETED
  INDUSTRY_UPDATED
  LOCATION_CHANGED
  GROWTH_MILESTONE
}

enum NewsCategory {
  ALLGEMEIN
  WIRTSCHAFT
  TECHNOLOGIE
  DIGITALISIERUNG
  NACHHALTIGKEIT
  EVENTS
  NETZWERK
  FOERDERUNG
  POLITIK
}



// ========== EVENT ACTIVITY LOGGING SYSTEM ==========

// Event Activity Log - alle Event-bezogenen Aktionen
model EventActivityLog {
  id          String          @id @default(uuid())
  userId      String
  eventId     String?

  // Event Action Details
  action      EventActionType
  description String?

  // Booking Details (falls relevant)
  spaces      Int?            // Anzahl gebuchter/stornierter Plätze
  totalCost   Float?          // Gesamtkosten
  bookingId   String?         // Referenz zur Booking

  // Event Status Tracking
  eventStatusBefore EventStatus?  // Status vor der Aktion
  eventStatusAfter  EventStatus?  // Status nach der Aktion

  // Technische Details
  ipAddress   String?
  userAgent   String?
  deviceType  DeviceType?
  sessionId   String?

  // Zusätzliche Daten
  metadata    Json?           // Beliebige zusätzliche Informationen
  success     Boolean         @default(true)
  errorMessage String?

  // Timestamps
  timestamp   DateTime        @default(now())

  // Relations
  user        User            @relation("UserEventLogs", fields: [userId], references: [id], onDelete: Cascade)
  event       Event?          @relation("EventActivityLogs", fields: [eventId], references: [id], onDelete: SetNull)
  booking     Booking?        @relation("BookingActivityLogs", fields: [bookingId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([eventId])
  @@index([action])
  @@index([timestamp])
  @@index([eventStatusAfter])
}

// ========== ENUMS FÜR EVENT LOGGING ==========

enum EventActionType {
  // Event Discovery
  EVENT_VIEWED           // User hat Event-Details angeschaut
  EVENT_LIST_VIEWED      // User hat Event-Liste angeschaut
  EVENT_SEARCHED         // User hat nach Events gesucht
  EVENT_FILTERED         // User hat Filter angewendet

  // Event Bookings
  BOOKING_STARTED        // User hat Buchungsprozess begonnen
  BOOKING_COMPLETED      // Buchung erfolgreich abgeschlossen
  BOOKING_CANCELLED      // Buchung wurde storniert
  BOOKING_MODIFIED       // Buchung wurde geändert (z.B. mehr Plätze)

  // Event Participation
  EVENT_ATTENDED         // User war bei Event anwesend
  EVENT_NO_SHOW          // User ist nicht erschienen
  EVENT_CHECKED_IN       // User hat sich bei Event eingecheckt

  // Event Interaction
  EVENT_SHARED           // Event wurde geteilt
  EVENT_FAVORITED        // Event zu Favoriten hinzugefügt
  EVENT_UNFAVORITED      // Event von Favoriten entfernt
  EVENT_RATED            // Event wurde bewertet
  EVENT_COMMENTED        // Kommentar zu Event hinterlassen

  // Calendar Integration
  CALENDAR_EXPORT        // Event in Kalender exportiert
  REMINDER_SET           // Erinnerung für Event gesetzt

  // Admin Actions (Event Management)
  EVENT_CREATED          // Event wurde erstellt
  EVENT_UPDATED          // Event wurde bearbeitet
  EVENT_PUBLISHED        // Event wurde veröffentlicht
  EVENT_UNPUBLISHED      // Event wurde versteckt/zurückgezogen
  EVENT_CANCELLED        // Event wurde abgesagt
  EVENT_POSTPONED        // Event wurde verschoben
  EVENT_COMPLETED        // Event als abgeschlossen markiert
  EVENT_ARCHIVED         // Event wurde archiviert
  EVENT_DELETED          // Event wurde gelöscht
}

// Event Status (für das Event selbst)
enum EventStatus {
  DRAFT          // Event erstellt, aber noch nicht veröffentlicht
  PUBLISHED      // Event ist live und buchbar
  FULL           // Event ist ausgebucht (maxParticipants erreicht)
  CANCELLED      // Event wurde abgesagt
  POSTPONED      // Event wurde verschoben
  COMPLETED      // Event ist beendet
  ARCHIVED       // Event ist archiviert
}

// User Booking Status (für User-Event-Beziehung)
enum UserBookingStatus {
  INTERESTED     // User zeigt Interesse
  BOOKED         // User hat Event gebucht
  CONFIRMED      // Buchung bestätigt
  CANCELLED      // User hat Buchung storniert
  ATTENDED       // User war anwesend
  NO_SHOW        // User nicht erschienen
  WAITLISTED     // User auf Warteliste
  CHECKED_IN     // User hat sich eingecheckt
}

enum DeviceType {
  DESKTOP
  MOBILE
  TABLET
  UNKNOWN
}

enum PaymentStatus {
  NOT_REQUIRED      // Kostenloses Event
  PENDING          // Zahlung ausstehend
  PAID             // Bezahlt
  PARTIALLY_REFUNDED // Teilweise erstattet
  REFUNDED         // Vollständig erstattet
  FAILED           // Zahlung fehlgeschlagen
  CANCELLED        // Storniert
}

enum PaymentMethod {
  BANK_TRANSFER
  INVOICE
  PAYPAL
}

model Cart {
  id        String     @id @default(uuid())
  userId    String
  user      User       @relation(fields: [userId], references: [id])
  items     CartItem[] // NEU: Relation zu CartItem
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

model CartItem {
  id        String   @id @default(uuid())
  cartId    String
  cart      Cart     @relation(fields: [cartId], references: [id])
  eventId   String
  event     Event    @relation(fields: [eventId], references: [id])
  spaces    Int      // Anzahl Tickets
  createdAt DateTime @default(now())
}

model Transaction {
  id                    String   @id @default(uuid())
  userId                String
  user                  User     @relation(fields: [userId], references: [id])
  amount                Float
  currency              String   @default("EUR")
  paymentMethod         String
  paymentStatus         PaymentStatus
  createdAt             DateTime @default(now())
  bookings              Booking[]
  externalTransactionId String?  @unique
  paypalResponse        Json?    // NEU: PayPal-Antwort als JSON
}

enum BookingStatus {
  PENDING
  COMPLETED
  CANCELLED
}
